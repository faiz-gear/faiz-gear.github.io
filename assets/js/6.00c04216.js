(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{329:function(n,e,t){"use strict";t.r(e);var s=t(26),a=Object(s.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",[n._v("一.父传子传递")]),n._v("\n（1）在父组件的子组件标签上绑定一个属性，挂载要传输的变量\n（2）在子组件中通过props来接受数据，props可以是数组也可以是对象，接受的数据可以直接使用 props: [“属性 名”] props:{属性名:数据类型}\n代码示例：\n"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//父组件\n<template>\n  <div>\n    <i>父组件</i>\n    \x3c!--页面使用--\x3e\n    <son :data=\'name\'></son> \n  </div>\n</template>\n<script>\nimport son from "./son.vue";//导入父组件\nexport default {\n  components: { son },//注册组件\n  name: "父组件",\n  data() {\n    return {\n      name: "Frazier", //父组件定义变量\n    };\n  },\n};\n<\/script>\n//子组件\n<template>\n  <div>{{data}}</div>\n</template>\n\n<script>\nexport default {\ncomponents: { },\n  name: \'子组件\',\n  props:["data"],\n};\n<\/script>\n')])])]),t("h2",[n._v("二.子传父传递")]),n._v("\n（1）在父组件的子组件标签上自定义一个事件，然后调用需要的方法 ​\n（2）在子组件的方法中通过 this.$emit(“事件”)来触发在父组件中定义的事件，数据是以参数的形式进行传递的\n代码示例：\n"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('//父组件\n<template>\n  <div>\n    <i>父组件</i>\n    \x3c!--页面使用--\x3e\n    <son @lcclick="lcclick"></son>//自定义一个事件\n  </div>\n</template>\n\n<script>\nimport son from "./son.vue"; //导入父组件\nexport default {\n  components: { son }, //注册组件\n  name: "父组件",\n  data() {\n    return {};\n  },\n  methods: {\n    lcclick(){\n      alert(\'子传父\')\n    }\n  },\n};\n<\/script>\n\n//子组件\n<template>\n  <div>\n    <button @click="lcalter">点我</button>\n  </div>\n</template>\n\n<script>\nexport default {\ncomponents: { },\n  name: \'子组件\',\n  methods: {\n    lcalter(){\n      this.$emit(\'lcclick\')//通过emit来触发事件\n    }\n  },\n};\n<\/script>\n')])])]),t("h2",[n._v("三.兄弟组件通信（bus总线）")]),n._v('\n（1）在src中新建一个Bus.js的文件，然后导出一个空的vue实例 ​\n（2）在传输数据的一方引入Bus.js 然后通过Bus.e m i t ( “ 事 件 名 ” , " 参 数 " ) 来 来 派 发 事 件 ， 数 据 是 以 emit(“事件名”,"参数")来来派发事件，数据是以emit(“事件名”,"参数")来来派发事件，数据是以emit()的参 数形式来传递 ​\n（3）在接受的数据的一方 引入 Bus.js 然后通过 Bus.$on(“事件名”,(data)=>{data是接受的数据})\n图片示例：\n![bus1](./assets/chuanzhi/bus1.png)\n![bus2](./assets/chuanzhi/bus2.png)\n![bus3](./assets/chuanzhi/bus3.png)\n'),t("h2",[n._v("四.ref/refs（父子组件通信）")]),n._v("\n（1）ref 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，\n（2）可以通过实例直接调用组件的方法或访问数据。也算是子组件向父组件传值的一种\n代码示例：\n"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//父组件\n<template>\n  <div>\n    <button @click=\"sayHello\">sayHello</button>\n    <child ref=\"childForRef\"></child>\n  </div>\n</template>\n<script>\nimport child from './child.vue'\n  export default {\n    components: { child },\n    data () {\n      return {\n        childForRef: null,\n      }\n    },\n    mounted() {\n      this.childForRef = this.$refs.childForRef;\n      console.log(this.childForRef.name);\n    },\n    methods: {\n      sayHello() {\n        this.childForRef.sayHello()\n      }\n    }\n  }\n<\/script>\n//子组件\n<template>\n  <div>child 的内容</div>\n</template>\n<script>\nexport default {\n  data () {\n    return {\n      name: '我是 child',\n    }\n  },\n  methods: {\n    sayHello () {\n      console.log('hello');\n      alert('hello');\n    }\n  }\n}\n<\/script>\n")])])]),t("h2",[n._v("五.Vuex通信")]),n._v("\n组件通过 dispatch 到 actions，actions 是异步操作，再 actions中通过 commit 到 mutations，mutations 再通过逻辑操作改变 state，从而同步到组件，更新其数据状态\n代码示例：\n"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//父组件\ntemplate>\n  <div id=\"app\">\n    <ChildA/>\n    <ChildB/>\n  </div>\n</template>\n<script>\n  import ChildA from './ChildA' // 导入A组件\n  import ChildB from './ChildB' // 导入B组件\n  export default {\n    components: {ChildA, ChildB} // 注册组件\n  }\n<\/script>\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//子组件A\n<template>\n <div id=\"childA\">\n   <h1>我是A组件</h1>\n   <button @click=\"transform\">点我让B组件接收到数据</button>\n   <p>因为点了B，所以信息发生了变化：{{BMessage}}</p>\n </div>\n</template>\n<script>\n export default {\n   data() {\n     return {\n       AMessage: 'Hello，B组件，我是A组件'\n     }\n   },\n   computed: {\n     BMessage() {\n       // 这里存储从store里获取的B组件的数据\n       return this.$store.state.BMsg\n     }\n   },\n   methods: {\n     transform() {\n       // 触发receiveAMsg，将A组件的数据存放到store里去\n       this.$store.commit('receiveAMsg', {\n         AMsg: this.AMessage\n       })\n     }\n   }\n }\n<\/script>\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//子组件B\n<template>\n <div id=\"childB\">\n   <h1>我是B组件</h1>\n   <button @click=\"transform\">点我让A组件接收到数据</button>\n   <p>点了A，我的信息发生了变化：{{AMessage}}</p>\n </div>\n</template>\n\n<script>\n export default {\n   data() {\n     return {\n       BMessage: 'Hello，A组件，我是B组件'\n     }\n   },\n   computed: {\n     AMessage() {\n       // 这里存储从store里获取的A组件的数据\n       return this.$store.state.AMsg\n     }\n   },\n   methods: {\n     transform() {\n       // 触发receiveBMsg，将B组件的数据存放到store里去\n       this.$store.commit('receiveBMsg', {\n         BMsg: this.BMessage\n       })\n     }\n   }\n }\n<\/script>\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//vuex\nimport Vue from 'vue'\n import Vuex from 'vuex'\n Vue.use(Vuex)\n const state = {\n   AMsg: '',\n   BMsg: ''\n }\n\n const mutations = {\n   receiveAMsg(state, payload) {\n     // 将A组件的数据存放于state\n     state.AMsg = payload.AMsg\n   },\n   receiveBMsg(state, payload) {\n     // 将B组件的数据存放于state\n     state.BMsg = payload.BMsg\n   }\n }\n\n export default new Vuex.Store({\n   state,\n   mutations\n })\n")])])]),t("h2",[n._v("六.$parent")]),n._v("\n​\t通过parent可以获父组件实例 ，然 后通过这个实例就可以访问父组件的属 性和方法 ，它还有一个兄弟root，可以获取根组件实例。\n代码示例：\n"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 获父组件的数据\nthis.$parent.foo\n\n// 写入父组件的数据\nthis.$parent.foo = 2\n\n// 访问父组件的计算属性\nthis.$parent.bar\n\n// 调用父组件的方法\nthis.$parent.baz()\n\n//在子组件传给父组件例子中，可以使用this.$parent.getNum(100)传值给父组件。\n")])])]),t("h2",[n._v("七.sessionStorage传值")]),n._v("\n​\tsessionStorage 是浏览器的全局对象，存在它里面的数据会在页面关闭时清除 。运用这个特性，我们可以在所有页面共享一份数据。\n代码示例：\n"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 保存数据到 sessionStorage\nsessionStorage.setItem('key', 'value');\n\n// 从 sessionStorage 获取数据\nlet data = sessionStorage.getItem('key');\n\n// 从 sessionStorage 删除保存的数据\nsessionStorage.removeItem('key');\n\n// 从 sessionStorage 删除所有保存的数据\nsessionStorage.clear();\n")])])]),t("p",[n._v("​\t注意：里面存的是键值对，只能是字符串类型，如果要存对象的话，需要使用 let objStr = \t\t\tJSON.stringify(obj) 转成字符串然后再存储（使用的时候 let obj = JSON.parse(objStr) 解析为对象）。\n推荐一个库 good-storage ，它封装了sessionStorage ，可以直接用它的API存对象")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//localStorage\n storage.set(key,val) \n storage.get(key, def)\n//sessionStorage\n storage.session.set(key, val)\n storage.session.get(key, val)\n")])])]),t("h2",[n._v("八.路由传值")]),n._v(" "),t("p",[t("strong",[n._v("使用问号传值")]),t("br"),n._v("\nA页面跳转B页面时使用 this.$router.push ( ’/B?name=danseek’),B页面可以使用this.route.query.name 来获取A页面传过来的值\n上面要注意$router和$route的区别\n"),t("strong",[n._v("使用冒号传值")]),t("br"),n._v("\n配置如下路由：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("{\n    path: '/b/:name',\n    name: 'b',\n    component: () => import( '../views/B.vue')\n },\n")])])]),t("p",[n._v("在B页面可以通过 this.$route.params.name 来获取路由传入的name的值")]),n._v(" "),t("p",[t("strong",[n._v("使用父子组件传值")]),t("br"),n._v("\n由于router-view本身也是一个组件，所以我们也可以使用父子组件传值方式传值，然后在对应的子页面里加上props，因为type更新后没有刷新路由，所以不能直接在子页面的mounted钩子里直接获取最新type的值，而要使用watch")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('<router-view :type="type"></router-view>\n\n// 子页面\nprops: [\'type\']\nwatch: {\n       type(){\n           // console.log("在这个方法可以时刻获取最新的数据:type=",this.type)\n       },\n},\n')])])]),t("h2",[n._v("九.祖传孙 $attrs")]),n._v("\n​\t正常情况下需要借助父亲的props作为中间过渡，但是这样在父亲组件就会多了一些跟父组件业务无关的属性，耦合度高，借助$attrs可以简化些，而且祖跟孙都无需做修改\n"),t("p",[t("strong",[n._v("祖组件：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('<template>\n    <section>\n        <parent name="grandParent" sex="男" age="88" hobby="code" @sayKnow="sayKnow"></parent>\n    </section>\n</template>\n\n<script>\n    import Parent from \'./Parent\'\n    export default {\n        name: "GrandParent",\n        components: {\n          Parent\n        },\n        data() {\n            return {}\n        },\n        methods: {\n          sayKnow(val){\n            console.log(val)\n          }\n        },\n        mounted() {\n        }\n    }\n<\/script>\n')])])]),t("p",[t("strong",[n._v("父组件")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('template>\n  <section>\n    <p>父组件收到</p>\n    <p>祖父的名字：{{name}}</p>\n    <children v-bind="$attrs" v-on="$listeners"></children>\n  </section>\n</template>\n\n<script>\n  import Children from \'./Children\'\n\n  export default {\n    name: "Parent",\n    components: {\n      Children\n    },\n    // 父组件接收了name,所以name值是不会传到子组件的\n    props:[\'name\'],\n    data() {\n      return {}\n    },\n    methods: {},\n    mounted() {\n    }\n  }\n<\/script>\n')])])]),t("p",[t("strong",[n._v("子组件")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("<template>\n  <section>\n    <p>子组件收到</p>\n    <p>祖父的名字：{{name}}</p>\n    <p>祖父的性别：{{sex}}</p>\n    <p>祖父的年龄：{{age}}</p>\n    <p>祖父的爱好：{{hobby}}</p>\n    \n    <button @click=\"sayKnow\">我知道啦</button>\n  </section>\n</template>\n\n<script>\n  export default {\n    name: \"Children\",\n    components: {},\n    // 由于父组件已经接收了name属性，所以name不会传到子组件了\n    props:['sex','age','hobby','name'],\n    data() {\n      return {}\n    },\n    methods: {\n      sayKnow(){\n        this.$emit('sayKnow','我知道啦')\n      }\n    },\n    mounted() {\n    }\n  }\n<\/script>\n")])])]),t("h2",[n._v("十.孙传祖使用$listeners")]),n._v("\n文字内容同第九个\n"),t("p",[t("strong",[n._v("祖组件")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("<template>\n  <div id=\"app\">\n    <children-one @eventOne=\"eventOne\"></children-one>\n    {{ msg }}\n  </div>\n</template>\n<script>\nimport ChildrenOne from '../src/components/children.vue'\nexport default {\n  name: 'App',\n  components: {\n    ChildrenOne,\n  },\n  data() {\n    return {\n      msg: ''\n    }\n  },\n  methods: {\n    eventOne(value) {\n      this.msg = value\n    }\n  }\n}\n<\/script>\n")])])]),t("p",[t("strong",[n._v("父组件")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("<template>\n  <div>\n    <children-two v-on=\"$listeners\"></children-two>\n  </div>\n</template>\n\n<script>\nimport ChildrenTwo from './childrenTwo.vue'\n\nexport default {\n  name: 'childrenOne',\n  components: {\n    ChildrenTwo\n  }\n}\n<\/script>\n")])])]),t("p",[t("strong",[n._v("子组件")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("<template>\n  <div>\n    <button @click=\"setMsg\">点击传给祖父</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'children',\n  methods: {\n    setMsg() {\n      this.$emit('eventOne', '123')\n    }\n  }\n}\n<\/script>\n")])])]),t("h2",[n._v("十一promise传参")]),n._v("\npromise 中 resolve 如何传递多个参数\n"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//类似与这样使用，但实际上后面两个参数无法获取\npromise = new Promise((resolve,reject)=>{\n    let a = 1\n    let b = 2\n    let c = 3\n    resolve(a,b,c) \n})\npromise.then((a,b,c)=>{\n    console.log(a,b,c)\n})\nresolve() 只能接受并处理一个参数，多余的参数会被忽略掉。\n如果想多个用数组，或者对象方式。。\n数组\n\npromise = new Promise((resolve,reject)=>{\n    resolve([1,2,3]) \n})\npromise.then((arr)=>{\n    console.log(arr[0],arr[1],arr[2])\n})\n\n对象\n\npromise = new Promise((resolve,reject)=>{\n    resolve({a:1,b:2,c:3}) \n})\npromise.then(obj=>{\n    console.log(obj.a,obj.b,obj.c)\n})\n")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);